===============================================JAVA实现分析========================================

秘钥获取过程：
==================第一步==========================================
hexString2binaryString:  8个字节  16进制转二进制
0:[0];1:[0];2:[0];3:[1];4:[0];5:[0];6:[1];7:[0];
8:[0];9:[0];10:[1];11:[1];12:[0];13:[1];14:[0];15:[0];
16:[0];17:[1];18:[0];19:[1];20:[0];21:[1];22:[1];23:[0];
24:[0];25:[1];26:[1];27:[1];28:[1];29:[0];30:[0];31:[0];
32:[1];33:[0];34:[0];35:[1];36:[0];37:[0];38:[0];39:[0];
40:[1];41:[0];42:[1];43:[0];44:[1];45:[0];46:[1];47:[1];
48:[1];49:[1];50:[0];51:[0];52:[1];53:[1];54:[0];55:[1];
56:[1];57:[1];58:[1];59:[1];60:[1];61:[1];62:[1];63:[0];

==================第二步==========================================
KeyPermutation1方法
resultKey[56]  key[64]
PC_1[] = new int[]{
	57,49,41,33,25,17,9,1,             7*8矩阵
	58,50,42,34,26,18,10,2,
	59,51,43,35,27,19,11,3,
	60,52,44,36,63,55,47,39,          置换算法resultKey[i] = key[PC_1[i]-1];	
	31,23,15,7,62,54,46,38,
	30,22,14,6,61,53,45,37,
	29,21,13,5,28,20,12,4};

密钥选择置换PC_1后的  64位转成56位秘钥
0:[1];1:[1];2:[1];3:[1];4:[0];5:[0];6:[0];7:[0];
8:[1];9:[1];10:[0];11:[0];12:[1];13:[1];14:[0];15:[0];
16:[1];17:[0];18:[1];19:[0];20:[1];21:[0];22:[1];23:[0];
24:[1];25:[0];26:[0];27:[1];28:[1];29:[0];30:[1];31:[0];
32:[0];33:[1];34:[0];35:[1];36:[1];37:[1];38:[0];39:[0];
40:[0];41:[1];42:[1];43:[0];44:[1];45:[1];46:[1];47:[0];
48:[1];49:[0];50:[0];51:[0];52:[1];53:[1];54:[1];55:[1];

前28位放LeftC0               后28位放RightD0
LeftC0 = new char[28]     RightD0 = new char[28];

==================第三步==========================================
1111000011001100101010101001 1010010111000110111010001111
16个迭代中 0 1 8 15次迭代左移一位；其他循环左移两位
第0次迭代左数组移位结果：1110000110011001010101010011
第0次迭代右数组移位结果：0100101110001101110100011111

==================第四步==========================================
CD选择置换PC_2 (56-48)

resultCd[48]  key[56]
PC_2[] = new int[]{
    14,17,11,24,1,5,3,28,          6*8矩阵
	15,6,21,10,23,19,12,4,
	26,8,16,7,27,20,13,2,          置换算法resultCd[i] = cd[PC_2[i]-1];
	41,52,31,37,47,55,30,40,
	51,45,33,48,44,49,39,56,
	34,53,46,42,50,36,29,32};

密钥选择置换PC_2后的  56位转成48位秘钥
0:[0];1:[0];2:[0];3:[1];4:[1];5:[0];6:[1];7:[1];
8:[0];9:[0];10:[0];11:[0];12:[0];13:[0];14:[1];15:[0];
16:[0];17:[1];18:[1];19:[0];20:[1];21:[1];22:[1];23:[1];
24:[1];25:[1];26:[0];27:[1];28:[0];29:[1];30:[1];31:[0];
32:[0];33:[1];34:[1];35:[1];36:[1];37:[0];38:[0];39:[1];
40:[0];41:[1];42:[1];43:[1];44:[0];45:[1];46:[0];47:[0];

此时，经过第三步，第四步，完成16轮移动和置换即刻得到KI，得到了秘钥


加密过程：
==================第一步：初始化置换==========================================
//将原明文进行IP置换 InitialPermutation
IP = new int[]{
	58,50,42,34,26,18,10,2,
	60,52,44,36,28,20,12,4,
	62,54,46,38,30,22,14,6,
	64,56,48,40,32,24,16,8,     result[i]= plain[IP[i]-1];
	57,49,41,33,25,17,9,1,
	59,51,43,35,27,19,11,3,
	61,53,45,37,29,21,13,5,
	63,55,47,39,31,23,15,7};

明文通过IP置换之后 64位
0:[0];1:[0];2:[0];3:[0];4:[0];5:[0];6:[0];7:[0];
8:[1];9:[1];10:[1];11:[1];12:[1];13:[1];14:[1];15:[1];
16:[0];17:[0];18:[0];19:[0];20:[0];21:[0];22:[0];23:[0];
24:[0];25:[1];26:[1];27:[1];28:[1];29:[1];30:[1];31:[1];
32:[0];33:[0];34:[0];35:[0];36:[0];37:[0];38:[0];39:[0];
40:[0];41:[0];42:[0];43:[0];44:[0];45:[0];46:[0];47:[0];
48:[0];49:[0];50:[0];51:[0];52:[0];53:[0];54:[0];55:[0];
56:[0];57:[0];58:[0];59:[0];60:[0];61:[0];62:[0];63:[0];

前32位afterIPLi   后32位afterIPRi
afterIPLi:00000000111111110000000001111111
afterIPRi:00000000000000000000000000000000
==================第二步：加密和异或==========================================
循环16次Feistel和异或运算： (1)EcryptFunction (2)XorAandB

第一次循环加密结果：
resultLi_1：00000000000000000000000000000000
resultRi_1：00011110111011010100000000100000 XorAandB(afterIPLi,EcryptFunction(afterIPLi,ki[0]))
   ......
resultLi_16:01011001101101100000101101001100
resultRi_16:01110011001101110000111100100111

==================第三步：拆解加密过程==========================================
EcryptFunction中：(1)扩展 (2)扩展结果与秘钥异或 (3)S盒子转换 (4)置换算法FunctionPermutation
获得Ri经过E扩展后的数组32-48   从32位扩展到48位  使用FunctionExtension方法

(1)扩展
Extension = new int[]{
	32,1,2,3,4,5,4,5,
	6,7,8,9,8,9,10,11,
	12,13,12,13,14,15,16,17,
	16,17,18,19,20,21,20,21,        扩展算法：resultRi[i] = tempRi[Extension[i]-1];
	22,23,24,25,24,25,26,27,
	28,29,28,29,30,31,32,1};

扩展前：
0:[0];1:[0];2:[0];3:[0];4:[0];5:[0];6:[0];7:[0];
8:[0];9:[0];10:[0];11:[0];12:[0];13:[0];14:[0];15:[0];
16:[0];17:[0];18:[0];19:[0];20:[0];21:[0];22:[0];23:[0];
24:[0];25:[0];26:[0];27:[0];28:[0];29:[0];30:[0];31:[0];

扩展后：
0:[0];1:[0];2:[0];3:[0];4:[0];5:[0];6:[0];7:[0];
8:[0];9:[0];10:[0];11:[0];12:[0];13:[0];14:[0];15:[0];
16:[0];17:[0];18:[0];19:[0];20:[0];21:[0];22:[0];23:[0];
24:[0];25:[0];26:[0];27:[0];28:[0];29:[0];30:[0];31:[0];
32:[0];33:[0];34:[0];35:[0];36:[0];37:[0];38:[0];39:[0];
40:[0];41:[0];42:[0];43:[0];44:[0];45:[0];46:[0];47:[0];

(2)扩展结果与秘钥异或
ki_0  : 000110110000001001101111110101100111100101110100
扩展后: 000000000000000000000000000000000000000000000000
异或后：000110110000001001101111110101100111100101110100

(3)S盒子转换
异或后：000110 110000 001001 101111 110101 100111 100101 110100
每6位一组，一共8组，在八个沙盒中取沙盒的值，算法如下：
int row = tem6in_int[0]*2+tem6in_int[5];
int column = tem6in_int[1]*8+tem6in_int[2]*4+tem6in_int[3]*2+tem6in_int[4];
int soutInt = Sbox[i][row][column];
1)第一组取出的值是：Sbox[0][0][3] = 1
2)Sbox[0][0][3]转化成十六进制string，然后在转化成二进制得到0001
3)讲0001每一位转化成十进制，然后在输出转化成char 放在outBox中，outBox是char[32]
4)转化结果：outBox: 00010101001110000000110011011010

Sbox = new int[][][]{
	//S0
	{{14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},
	{0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8},
	{4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0},
    {15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13}},
	// S1 
	{{15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10},
	{3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5},
	{0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},
	{13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9}},
	// S2 
	{{10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8},
	{13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1},
	{13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7},
	{1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12}},
	// S3 
	{{7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15},
	{13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9},
	{10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4},
	{ 3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14}},
	// S4 
	{{2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9},
	{14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6},
	{ 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14},
	{11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3}},
	// S5 
	{{12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11},
	{10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8},
	{9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6},
	{4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13}},
	// S6 
	{{4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1},
	{13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6},
	{1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2},
	{6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12}},
	// S7 
	{{13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7},
	{1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2},
	{7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8},
	{2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11}}};

(4)置换算法FunctionPermutation
outBox: 00010101001110000000110011011010
Permutation = new int[]{
	16,7,20,21,29,12,28,17,
	1,15,23,26,5,18,31,10,     resultPout[i] = tempSout[Permutation[i]-1];
	2,8,24,14,32,27,3,9,
	19,13,30,6,22,11,4,25};

原始：
0:[0];1:[0];2:[0];3:[1];4:[0];5:[1];6:[0];7:[1];
8:[0];9:[0];10:[1];11:[1];12:[1];13:[0];14:[0];15:[0];
16:[0];17:[0];18:[0];19:[0];20:[1];21:[1];22:[0];23:[0];
24:[1];25:[1];26:[0];27:[1];28:[1];29:[0];30:[1];31:[0];

转换之后：
0:[0];1:[0];2:[0];3:[1];4:[1];5:[1];6:[1];7:[0];
8:[0];9:[0];10:[0];11:[1];12:[0];13:[0];14:[1];15:[0];
16:[0];17:[1];18:[0];19:[0];20:[0];21:[0];22:[0];23:[0];
24:[0];25:[1];26:[0];27:[1];28:[1];29:[1];30:[1];31:[1];

==================第四步：初始化逆置换ReverseInitialPermutation===============
经过第三步的十六轮运算，回到第二步，左边32位和右边32位组合得到64位经过Feistel过程加密后的数据
resultLi_16:01011001101101100000101101001100
resultRi_16:01110011001101110000111100100111

置换前
0:[0];1:[1];2:[0];3:[1];4:[1];5:[0];6:[0];7:[1];
8:[1];9:[0];10:[1];11:[1];12:[0];13:[1];14:[1];15:[0];
16:[0];17:[0];18:[0];19:[0];20:[1];21:[0];22:[1];23:[1];
24:[0];25:[1];26:[0];27:[0];28:[1];29:[1];30:[0];31:[0];
32:[0];33:[1];34:[1];35:[1];36:[0];37:[0];38:[1];39:[1];
40:[0];41:[0];42:[1];43:[1];44:[0];45:[1];46:[1];47:[1];
48:[0];49:[0];50:[0];51:[0];52:[1];53:[1];54:[1];55:[1];
56:[0];57:[0];58:[1];59:[0];60:[0];61:[1];62:[1];63:[1];

置换矩阵
IPReverse = new int[]{
	40, 8, 48, 16, 56, 24, 64, 32, 
	39, 7, 47, 15, 55, 23, 63, 31,
	38, 6, 46, 14, 54, 22, 62, 30, 
	37, 5, 45, 13, 53, 21, 61, 29,       resultReverseIP[i] = afterCircleTmp[IPReverse[i]-1];
	36, 4, 44, 12, 52, 20, 60, 28, 
	35, 3, 43, 11, 51, 19, 59, 27,
	34, 2, 42, 10, 50, 18, 58, 26, 
	33, 1, 41,  9, 49, 17, 57, 25};

置换后
0:[1];1:[1];2:[1];3:[0];4:[1];5:[1];6:[1];7:[0];
8:[1];9:[0];10:[1];11:[1];12:[1];13:[1];14:[1];15:[0];
16:[0];17:[0];18:[1];19:[1];20:[1];21:[0];22:[1];23:[1];
24:[0];25:[1];26:[0];27:[0];28:[1];29:[1];30:[0];31:[1];
32:[1];33:[1];34:[1];35:[1];36:[0];37:[0];38:[0];39:[0];
40:[1];41:[0];42:[1];43:[1];44:[0];45:[0];46:[1];47:[0];
48:[1];49:[1];50:[0];51:[0];52:[0];53:[0];54:[0];55:[1];
56:[0];57:[0];58:[0];59:[1];60:[0];61:[0];62:[0];63:[0];

DES加密结果：1110 1110 1011 1110 0011 1011 0100 1101 1111 0000 1011 0010 1100 0001 0001 0000


解密过程和加密过程方法调用完全一样，过程也是完全一样的
==================第一步：初始化置换==========================================
==================第二步：加密和异或==========================================
==================第四步：初始化逆置换========================================

